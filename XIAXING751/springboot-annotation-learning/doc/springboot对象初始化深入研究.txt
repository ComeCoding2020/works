待整理 TODO

ConfigFileApplicationListener既是ApplicationListener还是EnvironmentPostProcessor，一专多能，我们系统中常用的application.yml就是通过ConfigFileApplicationListener注入的。

在Environment（Environment其实是由一个个顺序的PropertySource组成）准备好之后，Spring开始创建ApplicationContext（ApplicationContext顾名思义就是当前应用的上下文，默认是AnnotationConfigServletWebServerApplicationContext，该类主要组合了DefaultListableBeanFactory，DefaultListableBeanFactory主要用来注册all bean definitions），然后在prepareContext()中执行之前注册的initializers

这些initializers的执行时机在Bean加载之前，如图标注，Apollo注册了ApolloApplicationContextInitializer


具体操作为向Environment增加CompositePropertySource（该PropertySource提供的属性通过ConfigService.getConfig同步拉取），且放置到PropertySource列表第一位（Environment获取属性时会依次调用PropertySource获取，取到即止），所以此时Apollo的配置已全部拉取到本地文件和应用进程中（前提是网络没问题），Spring后续的Bean加载初始化过程中Apollo配置开始生效


如果apollo.bootstrap.enabled为false，Apollo是怎么玩的呢？
Apollo提供了注解@EnableApolloConfig支持配置获取（注意，这种方式下配置的生效时机就不再是Bean加载之前了，Bean创建的Condition条件中如果含有配置属性，是无法获取到的），该种方式主要采用了Spring的Bean加载初始化扩展机制

@EnableApolloConfig要和@Configuration一起配置，否则无法生效，这主要是借用了Spring的ConfigurationClass加载初始化机制

在上文提到的AnnotationConfigServletWebServerApplicationContext（即Spring Boot默认的ApplicationContext）里面有个AnnotatedBeanDefinitionReader属性， AnnotatedBeanDefinitionReader会向BeanFactory注册各种BeanFactoryPostProcessor和BeanPostProcessor，其中的ConfigurationClassPostProcessor主要负责ConfigurationClass的解析（used for bootstrapping processing of{@link Configuration @Configuration} classes），此处为Bean加载的入口，在后续的处理过程中会陆续加入各种BeanFactoryProcessor和BeanPostProcessor用于扩展


ConfigurationClassPostProcessor做了如下工作：

 进一步调用到ConfigurationClassParser 
 parser.parse()负责处理当前的ConfigurationClass，注意下图中的deferredImportSelectors，后面会用到 
 进一步调用到doProcessConfigurationClass() 
 回想一下，我们写Bean时有多种方式，@Configuration注解在class上，@Bean注解在method上...，如果跟启动类不在一个目录，还需要添加@ComponentSan，前面说到了@EnableApolloConfig要和@Configuration一起写，否则不生效，就是因为@EnableApolloConfig这种自定义注解是为了引入@Import注解，而@Import可以通过ImportBeanDefinitionRegistrar机制扩展引入BeanDefinition，@Import就是在@Configuration解析时处理的


Apollo是怎么就此扩展机制处理的呢？

 可以看到在ApolloConfigRegistrar中加入了各种BeanDefinition（主要为PostProcessor）


再进一步想一个问题，平常开发中，我们自定义的Bean总是先生效，Spring Boot各种Starter自带的Bean在加载时经常会先判断该Bean是否已定义，如DataSource Bean等，这就要求设计时有优先级顺序处理，Spring在ConfigurationClass parse时会判断是否为DeferredImportSelector和ImportBeanDefinitionRegistrar类型，如果是，则会先放到List中，后面再去处理，可见上面提到的deferredImportSelectors，还有下面代码中的loadBeanDefinitionsFromRegistrars
