《Redis实战》学习笔记
1.redis与其他数据库或缓存服务器的对比
2.为什么要用redis，redis的优势
  Redis是内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件
  数据库
  Redis本质是内存数据库，所以自然可以当做数据库来使用，但要注意的是内存空间是极其有限的，可不像硬盘那样浩瀚无垠，
  所以大多数情况下我们还是用关系型数据库+Redis缓存的方式运用Redis
  缓存
  比如Mysql，可承担的并发访问量有多大呢？答案是几百左右就会扛不住了，所以我们为了支持更高的并发，会使用缓存，为数
  据库筑起一道护盾，让大多数请求都发生在缓存这一层。Redis是把数据存储在内存上的，访问数据速度相当快，很适合做缓存。
  消息中间件
  Redis支持发布/订阅消息，当然真正的MQ我们一般在Rabbit，Rocket，卡夫卡之间选一个，这并不是Redis的强项
  Redis的特点：
  内存数据库，速度快，也支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
  Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
  Redis支持数据的备份，即master-slave模式的数据备份。
  支持事务
  Redis的优势：
  性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。
  丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
  原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。（事务）
  丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。
3.redis的五大数据类型
  
  (1) String
  Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的
  方式来减少内存的频繁分配，，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度
  小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。
  常用命令
  get 查询对应键值
  set 添加键值对  
  append 将给定的 追加到原值的末尾  
  strlen 获得值的长度  
  setnx 只有在 key 不存在时设置 key 的值  
  incr  
  将 key 中储存的数字值增1  
  只能对数字值操作，如果为空，新增值为1  
  decr 
  将 key 中储存的数字值减1  
  只能对数字值操作，如果为空，新增值为-1  
  incrby / decrby <步长>  
  将 key 中储存的数字值增减。自定义步长。  
  mset …  
  同时设置一个或多个 key-value对  
  mget …  
  同时获取一个或多个 value 
  msetnx …  
  同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。  
  getrange <起始位置> <结束位置>  
  获得值的范围，类似java中的substring  
  setrange <起始位置>  
  用 覆写 所储存的字符串值， 从<起始位置>开始。  
  setex <过期时间>  
  设置键值的同时，设置过期时间，单位秒。  
  getset  
  以新换旧，设置了新值同时获得旧值。
  
  (2) list
  单键多值
  Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素导列表的头部（左边）或者尾部（右边）。
  它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。操作的时间复杂度为 O(1)，
  但是索引定位很慢，时间复杂度为 O(n)
  常用命令
  lpush/rpush …
  从左边/右边插入一个或多个值。 
  lpop/rpop 
  从左边/右边吐出一个值。  
  值在键在，值光键亡。  
  rpoplpush  
  从列表右边吐出一个值，插到列表左边。  
  lrange  
  按照索引下标获得元素(从左到右)  
  lindex  
  按照索引下标获得元素(从左到右)  
  llen  
  获得列表长度  
  linsert before  
  在的后面插入 插入值  
  lrem  
  从左边删除n个value(从左到右)
  (3) set
  Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，
  又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是
  list所不能提供的。
  Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表,所以添加，删除，查找的复杂度都是O(1)。
  常用命令
  sadd …  
  将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。  
  smembers  
  取出该集合的所有值。  
  sismember  
  判断集合是否为含有该值，有返回1，没有返回0  
  scard  
  返回该集合的元素个数。  
  srem …  
  删除集合中的某个元素。  
  spop  
  随机从该集合中吐出一个值。 
  srandmember  
  随机从该集合中取出n个值。  
  不会从集合中删除  
  sinter  
  返回两个集合的交集元素。  
  sunion  
  返回两个集合的并集元素。  
  sdiff  
  返回两个集合的差集元素。
  (4) hash
  Redis hash 是一个键值对集合。
  Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。
  类似Java里面的Map
  常用命令
  hset  
  给集合中的 键赋值  
  hget  
  从集合 取出 value  
  hmset …  
  批量设置hash的值  
  hexists key  
  查看哈希表 key 中，给定域 field 是否存在。  
  hkeys  
  列出该hash集合的所有field  
  hvals  
  列出该hash集合的所有value  
  hincrby  
  为哈希表 key 中的域 field 的值加上增量 increment  
  hsetnx
  将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .
  (5) zset (sorted set)
  Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每个成员都关联了一个
  评分（score） ，这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分
  可以是重复了 。因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。访问有序集合的
  中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表
  常用命令
  zadd …
  将一个或多个 member 元素及其 score 值加入到有序集 key 当中。  
  zrange
  返回有序集 key 中，下标在 之间的元素  
  带WITHSCORES，可以让分数一起和值返回到结果集。  
  zrangebyscore key min max
  返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 
  zrevrangebyscore key max min
  同上，改为从大到小排列。  
  zincrby 
  为元素的score加上增量  
  zrem  
  删除该集合下，指定值的元素  
  zcount  
  统计该集合，分数区间内的元素个数 
  zrank
  返回该值在集合中的排名，从0开始。
4.发布与订阅
  发布与订阅（又称pub/sub）的特点是订阅者(listener)负责订阅频道(channel)，发送者(publisher)
  负责向频道发送二进制字符串消息(binary string message)。每当有消息被发送至给定频道时，频道的
  所有订阅者都会收到消息。
5.分布式锁
  一般来说，在对数据进行“加锁”时，程序首先需要通过获取锁来得到对数据进行排他性访问的能力，然后才能
  对数据执行一系列操作，最后还要将锁释放给其他程序。Redis使用WATCH命令来代替对数据进行加锁，因为
  WATCH只会在数据被其他客户端抢先修改了的情况下通知执行了这个命令的客户端，而不会阻止其他客户端对数据进行修改，所以这个命令被称为乐观锁。分布式锁也有类似的首先获取锁，然后执行操作，最后释放锁动作，但这种锁既不是给同一进程中的多个线程使用，也不是给同一台机器上的多个进程使用，而是由不同机器上的不同Redis客户端进行获取和释放。
6.粗粒度锁和细粒度锁 
  Redis提供了两种不同的持久化方法来将数据存储到硬盘里。一种方法叫快照(snapshotting)，它可以将存在于某
  一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件(append-only file, AOF)，它会在执行写命令时，
  将被执行的写命令复制到硬盘里面。Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。
  在创建快照之后，用户可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本，
  还可以将快照留在原地以便重启服务器时使用。
  创建快照的办法有以下几种：
  AOF持久化会将被执行的写命令写到AOF文件的末尾，以此来记录数据发生的变化。因此，Redis只要从头到尾重新
  执行一次AOF文件包含的所有写命令，就可以恢复AOF文件所记录的数据集。随着Redis不断运行，AOF文件的体积
  会不断增长，在极端情况下，体积不断增大的AOF文件甚至可能会用完硬件的所有可用空间。还有另一个问题就是，
  因为Redis在重启之后需要通过重新执行AOF文件记录的所有写命令来还原数据集，所以如果AOF文件的体积非常大，
  那么还原操作执行的时间就可能会非常长。为了解决AOF文件体积不断增大的问题，用户可以向Redis
  发送BGREWRITEAOF命令，这个命令会通过移除AOF文件中的冗余命令来重写AOF文件，使AOF文件的体积变得尽可能
  地小。跟快照持久化可以通过设置save选项来自动执行BGSAVE一样，AOF持久化也可以通过设置
  auto-aof-rewrite-percentage选项和auto-aof-rewrite-min-size选项来自动执行BGREWRITEAOF。
  复制可以让其他服务器拥有一个不断地更新的数据副本，从而使得拥有数据副本的服务器可以用于处理客户端发送的
  读请求。关系数据库通常会使用一个主服务器(master)向多个从服务器(slave)发送更新，并使用从服务器来处理
  所有读请求。Redis也采用了同样的方法来实现自己的复制特性，并将其用作扩展性能的一种手段。